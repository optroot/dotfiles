set encoding=utf-8
scriptencoding utf-8
" TODO don't use utf-8 here, make all special chars \"\uXXXX"

" ===================================================================== Initialization

if empty(glob('~/.vim/autoload/plug.vim'))
  silent! execute '!mkdir -p ~/.vim/undo'
  silent! execute '!mkdir -p ~/.vim/view'
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
        \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
endif

" ===================================================================== Plugins

call plug#begin('~/.vim/plugged')

Plug 'tommcdo/vim-exchange'
Plug 'tomtom/tcomment_vim'
Plug 'tpope/vim-abolish'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-unimpaired'
Plug 'tpope/vim-repeat'
Plug 'wellle/targets.vim'
Plug 'godlygeek/tabular'
Plug 'mbbill/undotree'
Plug 'sheerun/vim-polyglot', { 'do': './build' }

Plug 'christoomey/vim-tmux-navigator'
Plug 'tmux-plugins/vim-tmux-focus-events'

Plug 'scrooloose/nerdtree'
Plug 'tiagofumo/vim-nerdtree-syntax-highlight'
Plug 'Xuyuanp/nerdtree-git-plugin'

Plug 'tpope/vim-fugitive'
Plug 'airblade/vim-gitgutter'

Plug 'Yggdroot/indentLine'
" Plug 'kien/rainbow_parentheses.vim'
" Plug 'luochen1990/rainbow'
" Plug 'junegunn/rainbow_parentheses.vim'
" Plug 'losingkeys/vim-niji'
Plug 'eapache/rainbow_parentheses.vim'

Plug 'vim-airline/vim-airline'
Plug 'ryanoasis/vim-devicons'
Plug 'morhetz/gruvbox'

Plug 'panozzaj/vim-autocorrect', {'for': ['text', 'markdown'] }
Plug 'mattn/emmet-vim',          {'for': ['html', 'xml', 'php', 'markdown', 'css', 'less']}
Plug 'chrisbra/Colorizer',       {'for': ['vim', 'html', 'css', 'scss', 'sass']}

if has("python")
    Plug 'davidhalter/jedi-vim'
endif

if has("lua")
  Plug 'Shougo/neocomplete'
  Plug 'Shougo/neosnippet'
  Plug 'Shougo/neosnippet-snippets'
  Plug 'sbdchd/neoformat'
endif

if executable('ctags')
  Plug 'ludovicchabant/vim-gutentags', {'for': ['c', 'python', 'php']}
  Plug 'majutsushi/tagbar',            {'for': ['c', 'python', 'php']}
endif

call plug#end()

" ===================================================================== Options

" TODO no rainbow in text(ish) files
" TODO tab only at start of line (togglable)
" TODO namespace function to script (s:function)
" TODO if we haven't really changed a file (except whitespace, don't actually save)
" TODO no wW wrapping? or go to $ first
" TODO ghost completion
" TODO left/right map
" TODO More ! maps
" TODO more simple mappings
" TODO surround object mapping (quotes)
" TODO enforce single quotes where possible
" TODO change the fold color, it's confusing with splits
"   - keep syntax highlight, but dim, standout background more
" TODO folding auto syntax
"   - Functions
"   - Classes
"     - Methods
"   - Section comments
"   - python: if name
" markdown: Headings (top2)
" dynamic foldcolumn showing
" hotkey to enable/disable
" TODO use autocorrect for comments and other text portions
" Disable completion inside comments (or manual completion via C-<Space>?)
" TODO fix amiguous width characters have black beside
" TODO search hl off once edit action started
" syntax sync fromstart on open tags?
" TODO syntax for divider (any non-whitespace char repeated 20+ times, starting from starting of line)
" TODO vmode select up/down to whitespace
" Solution: { } and use A instead of I (^V{A instead of ^V{llllllI)
" Divider syntax
" Auto fold dividers (or cleverly hide {{{, }}}
" In somecases add / to keyword chars


filetype plugin indent on
syntax enable

set autoindent
set magic
set autoread
set backspace=indent,eol,start

" set cindent
" set cinoptions=(0,u0,U0

set cryptmethod=blowfish2
" set complete-=i
" set completeopt-=preview
set cpoptions+=$
set display+=lastline
set hidden
set history=1000
set ignorecase
set incsearch
set laststatus=2
set listchars=tab:â–¸\ ,eol:\ ,precedes:\ ,extends:\ ,trail:.
set noerrorbells
set noshowmatch
set nostartofline
set noswapfile
set nrformats-=octal
set number
set pastetoggle=<F2>
set report=1
set ruler
set scrolloff=8
set sessionoptions-=options
set showcmd
set showmode
set sidescrolloff=5
set smartcase
set tabpagemax=50
set undodir=~/.vim/undo
set undofile
set viewdir=~/.vim/view
set viminfo^=!
set virtualedit=all
set visualbell
set wildignorecase
set wildignore+=*/.git/*,*/.svn/*,*.o,*.pyc,*~,*.so,*.swp,*.zip,*.tar,*.tar.gz,
set wildmenu
set wildmode=full

set timeoutlen=1000
set updatetime=4000
set ttimeout
set ttimeoutlen=100

" TODO move to gutentags
setglobal tags-=./tags tags-=./tags; tags^=./tags;

" ===================================================================== Indent & Wrap

set textwidth=0 tabstop=4 softtabstop=4 shiftwidth=4 expandtab
set smartindent
set smarttab
set cindent
set nowrap

let g:PHP_outdentphpescape = 0
let g:PHP_vintage_case_default_indent = 1

" set cinoptions=
"       \>s,e0,n0,f0,{0,}0,
"       \^0,L-1,:s,=s,l0,b0,
"       \gs,hs,ps,ts,is,+s,
"       \c3,C0,/0,(0,u0,U0,
"       \w0,W1s,m1s,j1,J1,)20,*70,#0
" set cinoptions=(0,u0,U0,W1s,ms,j1,J1
set cinoptions=(0,u0,U0,W1s,ms,j1,J1

" ===================================================================== Clipboard

" TODO fix: this glitches out sometimes
if has("clipboard")
  set clipboard=exclude:cons\|linux

  " TODO Note that "a"*y has the expected behavior (luckily)
  nnoremap y "*y
  vnoremap y "*y

  " Paste from clipboard (requires unimpaired)
  nmap yop yo<C-R><C-O>*<ESC>
endif

" ===================================================================== Folds

" TODO
set foldenable
set foldmethod=manual
" set foldmethod=marker
" set foldcolumn=2
" set foldmethod=syntax
set foldnestmax=2

" ===================================================================== Conceal

if has('conceal')
  set conceallevel=2
  set concealcursor=vc
  let g:text_conceal='adgms'
  augroup Override
    autocmd!
    autocmd VimEnter * set concealcursor=vc
  augroup END
endif


" ===================================================================== Style

set title
let g:titlebase=substitute(system("whoami").'@'.system("hostname -f"),'\n','','g').':'
let &titlestring=g:titlebase."%(%{expand(\"%:p\")}%)"
let &t_ts="\e]2;"

set t_ut=
set t_Co=256
" set t_Co=88
set t_ZH=[3m
set t_ZR=[23m

if has("termguicolors")
  set termguicolors
endif

let g:indentLine_color_term=237
let g:indentLine_color_gui='#3c3836'
let g:indentLine_char='î˜¡'

let g:gruvbox_italic=1
let g:gruvbox_contrast_dark='hard'
let g:gruvbox_sign_column='bg0'
let g:gruvbox_invert_selection=0

" TODO group for escape sequences
" TODO non-visible chars
" syntax match unicode "[^\x100-\xffff]"
" highlight nonascii guibg='#000000' ctermbg=232
" TODO syntax for regular expressions in different languages
" syntax match nonascii "[^\x00-\x7f]"
" highlight nonascii guibg='#000000' guifg='#ff0000' ctermbg=232

try
    colorscheme gruvbox
catch /^Vim\%((\a\+)\)\=:E185/
  colorscheme default
endtry

set background=dark

highlight CursorLine     ctermbg=235 guibg=#282828

autocmd Syntax php highlight! link phpFunction GruvboxGreenBold
autocmd Syntax php highlight! link phpClass GruvboxGreenBold
autocmd Syntax php highlight! link phpFunctions GruvboxOrange

" TODO highlight Menu
" TODO highlight Scollbar
" TODO highlight Tooltip

" ===================================================================== Configuration

" Load matchit.vim, but only if the user hasn't installed a newer version.
if !exists('g:loaded_matchit') && findfile('plugin/matchit.vim', &runtimepath) ==# ''
  runtime! macros/matchit.vim
endif

let g:targets_quotes='"q ''s `'
" Only seek if next/last targets touch current line
let g:targets_seekRanges='cr cb cB lc ac Ac lr rr ll lb ar ab lB Ar aB Ab AB rb rB al Al'

let g:WebDevIconsUnicodeDecorateFolderNodes=1
let g:DevIconsEnableFoldersOpenClose=1
let g:DevIconsEnableFolderExtensionPatternMatching=0
let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols={}
let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols['html']='îœ¶'

" let g:airline_theme='base16_bright'
let g:airline_theme='gruvbox'
let g:airline_powerline_fonts=1
let g:airline#extensions#tabline#enabled=1
let g:airline#extensions#whitespace#enabled=0
let g:airline#extensions#capslock#enabled=1
let g:airline_section_z='%{g:airline_symbols.linenr}% %l:%v'
" let g:airline_section_a='%#__accent_bold#%{airline#util#wrap(airline#parts#mode(),0)}%#__restore__#%{airline#util#append(airline#parts#crypt(),0)}%{airline#util#append(airline#parts#paste(),0)}%{airline#util#append(airline#parts#spell(),0)}%{airline#util#append("",0)}%{airline#util#append("",0)}%{airline#util#append(airline#parts#iminsert(),0)}'
" let g:airline_section_a=
let g:airline_crypt_symbol="\ue0a2"

let g:webdevicons_enable_airline_tabline=0
let g:airline#extensions#tabline#buffer_nr_show=0
let g:airline#extensions#tabline#fnamemod=':t'
let g:airline#extensions#tabline#fnamecollapse=1
let g:airline#extensions#tabline#fnametruncate=10
let g:airline#extensions#tabline#show_close_button=0

let g:tcommentMaps=1
let g:tcommentMapLeader1=''
let g:tcommentMapLeader2=''
let g:tcommentMapLeaderOp1='gc'
let g:tcommentMapLeaderUncommentAnyway='g<'
let g:tcommentMapLeaderCommentAnyway='g>'
let g:tcommentTextObjectInlineComment='ic'


" let g:rbpt_colorpairs = [
"     \ ['brown',       'RoyalBlue3'],
"     \ ['Darkblue',    'SeaGreen3'],
"     \ ['darkgray',    'DarkOrchid3'],
"     \ ['darkgreen',   'firebrick3'],
"     \ ['darkcyan',    'RoyalBlue3'],
"     \ ['darkred',     'SeaGreen3'],
"     \ ['darkmagenta', 'DarkOrchid3'],
"     \ ['brown',       'firebrick3'],
"     \ ['gray',        'RoyalBlue3'],
"     \ ['black',       'SeaGreen3'],
"     \ ['darkmagenta', 'DarkOrchid3'],
"     \ ['Darkblue',    'firebrick3'],
"     \ ['darkgreen',   'RoyalBlue3'],
"     \ ['darkcyan',    'SeaGreen3'],
"     \ ['darkred',     'DarkOrchid3'],
"     \ ['red',         'firebrick3'],
"     \ ]

let g:rbpt_colorpairs = [
    \ ['167', '#fb4934'],
    \ ['208', '#fe8019'],
    \ ['214', '#fabd2f'],
    \ ['142', '#b8bb26'],
    \ ['66',  '#83a598'],
    \ ['175', '#d3869b'],
    \ ]
let g:rbpt_max = 12
let g:bold_parentheses = 1 

au VimEnter * RainbowParenthesesToggle
au Syntax * RainbowParenthesesLoadRound
au Syntax * RainbowParenthesesLoadSquare
au Syntax * RainbowParenthesesLoadBraces

let g:user_emmet_mode='iv'
imap <silent> <expr> <C-@> emmet#expandAbbrIntelligent("\<C-@>")
vmap <silent> <C-@> :call emmet#expandAbbr(0,'')

let g:gitgutter_max_signs=999
nnoremap cog :GitGutterToggle<CR>

nnoremap cof :let &foldcolumn=2-&foldcolumn<CR>

let g:NERDTreeShowHidden=1
let g:NERDTreeIgnore=['\.pyc$','^.git$']

let g:gutentags_enabled=0
let g:gutentags_tagfile='.tags'
let g:gutentags_project_root=['.git']

" TODO try not showing menu, max_list = 1
" let g:neocomplete#force_overwrite_completefunc = 1
let g:acp_enableAtStartup = 0

let g:neocomplete#enable_at_startup = 1
" let g:neocomplete#enable_at_startup = 0
let g:neocomplete#max_list = 20
let g:neocomplete#max_keyword_width = 40
let g:neocomplete#auto_completion_start_length = 2
let g:neocomplete#min_keyword_length = 4
let g:neocomplete#enable_auto_delimiter = 1

" TODO no completion in comments
let g:neocomplete#enable_auto_select = 1
" let g:neocomplete#text_mode_filetypes
" let g:neocomplete#enable_quick_match = 1
" let g:neocomplete#delimiter_patterns
" let g:neocomplete#sources
" let g:neocomplete#enable_auto_clone_preview = 1

if has("timers")
  let g:neocomplete#auto_complete_delay = 200
endif

" Enable heavy omni completion.
if !exists('g:neocomplete#keyword_patterns')
  let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns._ = '\h\w*'
" let g:neocomplete#keyword_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
" let g:neocomplete#keyword_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
" let g:neocomplete#keyword_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
" let g:neocomplete#keyword_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
" let g:neocomplete#force_omni_input_patterns.python = '\%([^. \t]\.\|^\s*@\|^\s*from\s.\+import \|^\s*from \|^\s*import \)\w*'

" TODO more accurate way of doing this?
if has("lua")
  inoremap <silent> <expr> <BS> neocomplete#smart_close_popup()."\<BS>"
  inoremap <silent> <expr> <CR> neocomplete#smart_close_popup()."\<CR>"
  inoremap <silent> <expr> <TAB> TAB_Handler()
  smap <expr> <TAB> neosnippet#expandable_or_jumpable() ?
        \ "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"
endif

function! TAB_Handler()
  " If at end of line and clike langs get {}
  let l:out = ""
  if pumvisible()
    " let l:out = "\<C-y>"
    let l:out = l:out.neocomplete#close_popup()
    return l:out
    "C-y"
    return neocomplete#smart_close_popup()
  endif
  if neosnippet#expandable_or_jumpable()
    let l:out = l:out.neosnippet#mappings#jump_or_expand_impl()
  elseif !pumvisible()
    let l:out = l:out."\<TAB>"
  endif
  return l:out
endfunction

autocmd FileType c             setlocal omnifunc=ccomplete#Complete
autocmd FileType css           setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html          setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript    setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType java          setlocal omnifunc=javacomplete#Complete
autocmd FileType markdown      setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType php           setlocal omnifunc=phpcomplete#CompletePHP
autocmd FileType python        setlocal omnifunc=jedi#completions
autocmd FileType ruby          setlocal omnifunc=rubycomplete#Complete
autocmd FileType xml           setlocal omnifunc=xmlcomplete#CompleteTags

" TODO respect local sw
let g:neoformat_basic_format_align = 1
let g:neoformat_basic_format_retab = 1
let g:neoformat_basic_format_trim = 1
nnoremap <silent> <buffer> <F4> :Neoformat<CR>
"TODO vmode

let g:jedi#completions_enabled = 0
let g:jedi#auto_vim_configuration = 0


" ===================================================================== Autocmds

augroup VimOptions
  autocmd!
  autocmd FileType * silent! setlocal formatoptions-=c formatoptions-=r formatoptions-=o
augroup END

augroup Filetypes
  autocmd BufRead,BufNewFile *.zsh-theme silent! setfiletype=zsh
augroup END

augroup Theme
  autocmd!
  autocmd WinLeave,FocusLost                        * setlocal nocursorline
  autocmd VimEnter,WinEnter,BufWinEnter,FocusGained * setlocal cursorline
augroup END

augroup Startup
  autocmd!
  autocmd VimEnter    * silent! GitGutterDisable
  autocmd BufEnter    * silent! call SetTmuxTitle()
  autocmd VimEnter    * silent! call SetTmuxTitle()
  autocmd VimLeave    * silent! call SetTmuxTitle(system("basename $SHELL"))
  autocmd BufWinLeave * silent! mkview!
  autocmd BufWinEnter * silent! loadview
augroup END

augroup LanguageOptions
  autocmd!

  autocmd FileType javascript,json,css,less,html,vim setlocal tabstop=2 softtabstop=2 shiftwidth=2 expandtab
  autocmd FileType Makefile                          setlocal tabstop=4 softtabstop=4 shiftwidth=4 noexpandtab
  autocmd FileType html,markdown,css,text setlocal textwidth=78
  autocmd FileType html,markdown,css,text setlocal wrap

  " TODO finish set iskeyword=@,48-57,_,192-255
  " TODO _ not part of word for some operations?
  " autocmd FileType c,cpp,php,css,less,markdown,html,xml,javascript setlocal iskeyword+=-
  " autocmd FileType php,css,less,javascript                setlocal iskeyword+=$
  " autocmd FileType c,cpp,php                              setlocal iskeyword+=>
  " autocmd FileType css,less                               setlocal iskeyword+=.,#,\@

  autocmd FileType c,cpp,php,javascript,python let g:gutentags_enabled=1
  autocmd FileType c,cpp,php,javascript,python call GutenTagsDisableFileSize(1*1024*1024)

augroup END

function! GutenTagsDisableFileSize(cap)
  if getfsize(@%) > a:cap
    let g:gutentags_enabled=0
  endif
endfunction

" if exists(':CompletorDisable')
"   augroup PluginCompletor
"     autocmd FileType markdown,text execute ':CompletorDisable'
"   augroup END
" endif
"
" if exists('AutoCorrect')
"   augroup PluginAutoCorrect
"     autocmd Filetype text,markdown call AutoCorrect()
"   augroup END
" endif
"
" augroup AutoSpellCheck
"   autocmd FileType markdown,text setlocal spell
" augroup END
" if exists(':Autoformat')
"   nnoremap <silent> <buffer> <F4> :Autoformat<CR>
" endif
"
" Autocorrect and set spell in git commit


" TODO if project has makefile use it
" TODO move to LanguageOptions
augroup Evaluate
  autocmd!
  autocmd BufWritePost *.tex call TmuxSplitCmd('pdflatex -synctex=-1 -halt-on-error','%p')
  autocmd FileType html     silent! nnoremap <silent> <buffer> <F5> :silent! call TmuxSplitCmd('http')<CR>
  autocmd FileType python   silent! nnoremap <silent> <buffer> <F5> :silent! call TmuxSplitCmd('python','%:p')<CR>
  autocmd FileType sh       silent! nnoremap <silent> <buffer> <F5> :silent! call TmuxSplitCmd('source','%:p')<CR>
  autocmd FileType less     silent! nnoremap <silent> <buffer> <F5> :silent! call TmuxSplitCmd('lessc','%:p')<CR>
  autocmd FileType vim      silent! nnoremap <silent> <buffer> <F5> :so %<CR>
  autocmd FileType markdown silent! nnoremap <silent> <buffer> <F5> :silent! call Markdown()<CR>
  " TODO Fix
  "autocmd FileType c        silent! nnoremap <silent> <buffer> <F5> :call TmuxSplitCmd('gcc -Wall ','%:p',' -o ','%:r',' \&\& ./','%:r')<CR>
  "autocmd FileType matlab   silent! nnoremap <silent> <buffer> <F5> :call TmuxSplitCmd('matlab -nosplash -nodesktop -r "run(''','%p',''')"')<CR>
augroup END

" ===================================================================== Abbreviations

" Fix common programmer typos
iabbrev prinft    printf
iabbrev pritn     print
iabbrev retunr    return
iabbrev retrun    return
iabbrev reutrn    return
iabbrev retyrn    return
iabbrev improt    import
iabbrev ciel      ceil

" ===================================================================== Mappings

" RSI commands
cnoremap <C-A> <HOME>
inoremap <C-E> <END>

" Open file shortcut
noremap  \\   :NERDTreeToggle<CR>
nnoremap \vi  :e $MYVIMRC<CR>
nnoremap \sh  :e ~/.bashrc<CR>
nnoremap \tm  :e ~/.tmux.conf<CR>
" nnoremap \s   :UltiSnipsEdit<CR>
nnoremap \t   :e ~/projects/util/todo/todo.md<CR>

" Fkey mappings (F2 paste, F5 eval)
" TODO if exists
nnoremap <silent> <F1> :call TmuxSplitCmd()<CR>
noremap <silent> <F6> :call EvalCmd('python')<CR>

" TODO make the command show in history
" noremap <silent> <F7> Y:@"<CR>
noremap <F7> ^y$:<C-R>"<CR>

" nnoremap yy ^y$

" nnoremap <silent> <F8> :TagbarToggle<CR>
" nnoremap <silent> <F9> :UndotreeToggle<CR>
nnoremap <silent> <F10>  :call GetColors()<CR>
nnoremap <silent> <F11> :call SyntaxStack()<CR>
" nnoremap <silent> <F12> :so $MYVIMRC<CR>

" Fix behavior
inoremap <C-U> <C-G>u<C-U>
nnoremap <silent> j gj
nnoremap <silent> k gk
nnoremap <silent> gj j
nnoremap <silent> gk k
inoremap <C-C> <C-[>
xnoremap <silent> . :norm .<CR>

" Center the cursor
nnoremap n nzzzv
nnoremap N Nzzzv

" Allow inc/dec columns
vnoremap <C-A> g<C-A>
vnoremap <C-X> g<C-X>

inoremap <C-A> <HOME>
inoremap <C-E> <END>

nnoremap <C-W>h 10<C-W><
nnoremap <C-W>j 10<C-W>+
nnoremap <C-W>k 10<C-W>-
nnoremap <C-W>l 10<C-W>>

" TODO xmap
" Moving Visuals
nnoremap gV `[V`]
vmap <DOWN> xpgV
vmap <UP> xkkpgV
vnoremap <LEFT> <gv
vnoremap <RIGHT> >gv

nnoremap <UP> {
nnoremap <DOWN> }

" Forgive capital normal commands
command! -bang -nargs=? -complete=file E e<bang> <args>
command! -bang -nargs=? -complete=file W w<bang> <args>
command! -bang -nargs=? -complete=file Q q<bang> <args>
command! -bang -nargs=? -complete=file Wq wq<bang> <args>
command! -bang -nargs=? -complete=file WQ wq<bang> <args>

" Leader Mappings
let g:mapleader=' '
nnoremap <leader>2     :setlocal tabstop=2 softtabstop=2 shiftwidth=2 expandtab<CR>
nnoremap <leader>4     :setlocal tabstop=4 softtabstop=4 shiftwidth=4 expandtab<CR>
nnoremap <leader><TAB> :setlocal tabstop=4 softtabstop=4 shiftwidth=4 noexpandtab<CR>
" TODO syntax sync fromstart
" vnoremap <leader>r  :redraw!<CR>
vnoremap <leader>=  :Tab/=<CR>gv
vnoremap <leader>:  :Tab/:\zs<CR>gv
vnoremap <leader>,  :Tab/,\zs<CR>gv
nnoremap <silent> <leader>d :silent! call DeleteHiddenBuffers()<CR>
nnoremap <silent> <leader>q :silent! call DeleteHiddenBuffers()<CR>
nnoremap <leader><leader> ga

nnoremap !! :e $MYVIMRC<CR>Go<C-R>:<ESC>

" vnoremap {
" vnoremap }

" TODO if exchange
" s for swap a for argument
" TODO sa cxi, sometimes?
nmap sa cxIa
nmap sqs cs"'
nmap ssq cs'"
nmap sw cxiw
nmap sW cxiW

"TODO swap what's in register "
" nmap ss
" nmap s"

" TODO fix?
nmap sna cxiacxina
nmap snb cxibcxinb
" nmap snt cxitcxint
" nmap snt cxatcxant

" TODO surround + welle quotes

" TODO if targets+surround
nmap dsq ds"
nmap dss ds'

nmap ssb ys$b
nmap swb ysiWb

" ===================================================================== Plugin - Hide Vim Meta
" TODO
" Allow use of {{{ and }}} for folding, without saving
" Allow use of #vim:<settings>

" ===================================================================== Plugin - NerdTree dircolors


" NERDTress File highlighting
" TODO guifg
function! NERDTreeHighlightFile(extension, fg)
  exec 'autocmd FileType nerdtree highlight ' . a:extension .'  ctermfg='. a:fg
  exec 'autocmd FileType nerdtree syn match ' . a:extension .' #^\s\+.*'. a:extension .'$#'
endfunction

" " TODO open dircolors
" call NERDTreeHighlightFile('jpg', 97)
" call NERDTreeHighlightFile('ico', 97)
" call NERDTreeHighlightFile('png', 97)
" call NERDTreeHighlightFile('md', 229)
" call NERDTreeHighlightFile('json',222)
" call NERDTreeHighlightFile('html',97)
" call NERDTreeHighlightFile('css', 125)
" call NERDTreeHighlightFile('less',125)
" call NERDTreeHighlightFile('js',42)
" call NERDTreeHighlightFile('py', 42)
" call NERDTreeHighlightFile('php', 42)
" call NERDTreeHighlightFile('gitignore',240)

" ===================================================================== Plugin - Evaluate

command! -range PassRange call EvalCmd()
function! EvalCmd(cmd) range
  exec a:firstline.','.a:lastline.'!'.a:cmd
  redraw!
endfunction

" TODO
function! Markdown()
  silent! call system('markdown-pdf '.expand('%:p'))
  silent! call system('markdown-html '.expand('%:p'))
  " let l:cmd='(echo "# '.expand('%:r').'" && echo "## Table of contents" && markdown-toc '.expand('%:p').' && echo && cat '.expand('%:p').')  | marked  | bootstrapify '.expand('%:r').' | (tidy -config ~/.tidy.conf 2> /dev/null) > '.expand('%:r').'.html'
  " silent! call system(l:cmd)
  " execute 'sleep 1000m'
  " silent! call TmuxSplitCmd('http')
  " let l:cmd='(echo "# '.expand('%:r').'" && echo "## Table of contents" && markdown-toc '.expand('%:p').' && echo && cat '.expand('%:p').')  | marked | '
  " echo l:cmd
  " silent! call system(l:cmd)
  redraw!
endfunction

" ===================================================================== Plugin - Tmux Split

function! TmuxRunning()
  return ($TMUX != '')
endfunction

function! SetTmuxTitle(...)
  if !TmuxRunning()
    return
  endif
  let l:t=system("tmux display-message -p '#W'")
  if l:t[0] =~# '[A-Z]'
    return
  endif
  let l:project=system('~/bin/project -fa')
  let l:curfile=tolower(expand('%:p:t:r'))
  if a:0 > 0
    silent! call system('tmux rename-window '.a:1)
  elseif l:project !=# ''
    silent! call system('tmux rename-window '.l:project)
  elseif l:curfile !=# ''
    silent! call system('tmux rename-window '.l:curfile)
  else
    silent! call system('tmux rename-window '.'vim')
  endif
endfunction

" WARNING only use with 1 bottom split
"function! TmuxSplitCmd(cmd, ...)
function! TmuxSplitCmd(...)
  if !TmuxRunning()
    return
  endif
  if len(split(system('tmux list-panes'), "\n")) == 1
    silent! call system('tmux new-window -dn vimshell -c '.shellescape(getcwd()))
    silent! call system('tmux join-pane -dvl 12 -s vimshell')
    execute 'sleep 500m'
  endif
  if a:0 >= 0
    "silent! call system('tmux send-keys -t bottom ')
    silent! call system('tmux send-keys -t bottom ')
    execute 'sleep 500m'
    let l:cmd=join(map(copy(a:000), 'expand(v:val)'),'\ ')
    if len(l:cmd) > 0
      silent! call system('tmux send-keys -t bottom '.l:cmd.'')
    endif
  endif
endfunction

" ===================================================================== Plugin - Syntax Helper

function! GetColors()
  let l:fg='-1'
  let l:bg='-1'
  for l:id in synstack(line('.'), col('.'))
    let l:bold=synIDattr(synIDtrans(l:id), 'l:bold')
    let l:italic=synIDattr(synIDtrans(l:id), 'l:italic')
    let l:fg=l:fg==#'-1'? synIDattr(synIDtrans(l:id), 'l:fg') : l:fg
    let l:bg=l:bg==#'-1'? synIDattr(synIDtrans(l:id), 'l:bg') : l:bg
  endfor
  let l:fg=l:fg==#'-1'? synIDattr(hlID('Normal'),'l:fg') : l:fg
  let l:bg=l:bg==#'-1'? synIDattr(hlID('Normal'),'l:bg') : l:bg
  let l:fg=l:fg==#'-1'? 'Terminal' : l:fg
  let l:bg=l:bg==#'-1'? 'Terminal' : l:bg
  echo 'fg: ['.l:fg.'] bg: ['.l:bg.']'
endfunction

function! SyntaxStack()
  let l:s=[]
  for l:id in synstack(line('.'), col('.'))
    let l:real_name=synIDattr(l:id, 'name')
    let l:syntax_name=synIDattr(synIDtrans(l:id), 'name')
    if l:real_name == l:syntax_name
      call add(l:s,'['.l:real_name.']')
    else
      call add(l:s,'['.l:real_name.' as '.l:syntax_name.']')
    end
  endfor
  echo join(l:s, ' -> ')
endfunction

" ===================================================================== Plugin - Change Extension (dext)

" TODO move to plugin
command! -nargs=1 Ext call ChangeExt(<q-args>)

function! ChangeExt(ext)
  let l:fn=expand('%:p')
  let l:base=expand('%:p:r')
  if filereadable(l:fn)
    execute 'file '.l:base.'.'.a:ext
    call delete(l:fn)
    execute 'write | edit'
  else
    execute 'file '.l:base.'.'.a:ext
  endif
endfunction

" ===================================================================== Plugin - Buffer

function! DeleteHiddenBuffers()
  let l:tpbl=[]
  call map(range(1, tabpagenr('$')), 'extend(l:tpbl, tabpagebuflist(v:val))')
  for l:buf in filter(range(1, bufnr('$')), 'bufexists(v:val) && index(l:tpbl, v:val)==-1')
    silent execute 'bdelete' l:buf
  endfor
endfunction

set switchbuf=usetab
function! TabOrBuffer(direction)
  " Not contiguous
  let l:tabs = tabpagenr('$')
  if     a:direction ==? 'prev' && l:tabs > 1
    tabprevious
  elseif a:direction ==? 'next' && l:tabs > 1
    tabnext
  elseif a:direction ==? 'prev'
    bnext!
  else
    bprevious!
  endif
  " let l:tabno = tabpagenr()
  " let l:bufs = bufnr('$')
  " let l:bufno = bufnr('%')
  " bufloaded()
  " tabpagebuflist()
endfunction
"nnoremap <LEFT> :sbnext<CR>
"nnoremap <RIGHT> :sbprev<CR>
" TODO order?
nnoremap <silent> <RIGHT> :silent! call TabOrBuffer('prev')<CR>
nnoremap <silent> <LEFT>  :silent! call TabOrBuffer('next')<CR>
nnoremap <silent> <TAB>   :bnext<CR>
nnoremap <silent> <S-TAB> :bprevious<CR>
" TODO tabmove
" Tab switching

" ===================================================================== Plugin - EndAll

" TODO MERGE WITH SEMICOLON MAGIC
" imap <C-_> <ESC>:call EndHTMLTag()<CR>A

" TODO don't use marks/registers
" TODO More efficient, Avoid moving around
" function! EndHTMLTag()
"   execute "normal mpA</\<C-X>\<C-O>\<ESC>%ll\"tyw"
"   let l:lineNow=line('.')
"   let l:posNow=col('.')
"   execute 'normal $h%mm'
"   let l:lineMatch=line('.')
"   let l:posMatch=col('.')
"   if (l:lineNow == l:lineMatch) && (l:posNow == l:posMatch+2)
"     execute 'normal $%D'
"   elseif l:lineNow == l:lineMatch
"     execute 'normal `p'
"   else
"     execute 'normal 0''sy^'
"     execute 'normal `p$%''md$'
"     if index(['div'], @t)>=0
"       let l:line=getline(l:lineMatch)
"       let l:attrs={'id':'#', 'class':'.'}
"       for l:attr in keys(l:attrs)
"         let l:an=match(l:line, ' '.l:attr.'=')
"         if l:an >= 0
"           let l:q1=match(l:line, '"', l:an, 1)+1
"           let l:q2=match(l:line, '"', l:an, 2)-1
"           let l:name=split(l:line[(l:q1):(l:q2)], ' ')[0]
"           let @m .= ' <!-- '.l:attrs[l:attr].l:name.' -->'
"           break
"         end
"       endfor
"     end
"     if match(getline('.'), '^\s*$') < 0
"       execute 'normal o\<C-R>m\<ESC>0d^''sPo'
"     else
"       execute 'normal 0i\<C-R>s\<C-R>m\<CR>'
"     endif
"   endif
" endfunction


" ===================================================================== Plugin - Stealth

" Call :X for encryption
" TODO setlocal viminfo isn't working correctly?
function! SetStealthMode()
  augroup Encryption
    " TODO syntax not correct here?
    autocmd!
    autocmd BufReadPost,FileReadPre setlocal noswapfile
    autocmd BufReadPost,FileReadPre setlocal nobackup
    autocmd BufReadPost,FileReadPre setlocal nowritebackup
    autocmd BufReadPost,FileReadPre setlocal noundofile
    autocmd BufReadPost,FileReadPre autocmd! views
    autocmd BufReadPost,FileReadPre set viminfo=
  augroup END
endfunction

augroup DetectEncryption
  autocmd!
  autocmd BufReadPre,FileReadPre *.gpg.* call SetStealthMode()
augroup END

" ===================================================================== Plugin - Folding

" TODO fold first function/class only
"  -> variable for filetype delimiters
" TODO fold between comment dividers

" set foldmethod=expr
" set foldexpr=GetFold

" function! GetFold(lnum)
"
"     " Determine the current folding level
"     let line=getline(a:lnum)
"     let cind=indent(a:lnum)
"
"     " Get the next non-blank line
"     let nnum  = nextnonblank(a:lnum + 1)
"     let nind  = indent(nnum)
"     let nline = getline(nnum)
"
"     " Get the previous non-blank line
"     let pnum = prevnonblank(a:lnum - 1)
"
"     " Get the previous line indent level
"     let plvlnum = a:lnum - 1
"     let lvl = foldlevel(plvlnum)
"
"     " let retStr = "<" . (cind / &sw + 1)
"
"     " if line =~ '^\(class\|def\)\s'
"     "     return '>'
"     " endif
"
"     return '='
" endfunction


" ===================================================================== EXPERIMENTAL

" set cmdheight=2


